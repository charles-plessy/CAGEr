% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ClusteringFunctions.R
\name{distclu-functions}
\alias{distclu-functions}
\alias{.cluster.ctss.strand}
\alias{.cluster.ctss.chr}
\alias{.ctss2clusters}
\alias{.summarize.clusters}
\alias{.distclu}
\title{Private functions for distance clustering.}
\usage{
.cluster.ctss.strand(ctss.ipos.chr, max.dist)

.cluster.ctss.chr(ctss.chr, max.dist)

.ctss2clusters(ctss, max.dist = 20, useMulticore = FALSE, nrCores = NULL)

.summarize.clusters(
  ctss.clustered,
  removeSingletons = FALSE,
  keepSingletonsAbove = Inf
)

.distclu(
  se,
  max.dist = 20,
  removeSingletons = FALSE,
  keepSingletonsAbove = Inf,
  useMulticore = FALSE,
  nrCores = NULL
)
}
\arguments{
\item{ctss.ipos.chr}{A IPos object.}

\item{max.dist}{See \code{\link[=clusterCTSS]{clusterCTSS()}}.}

\item{ctss.chr}{A CTSS.chr object.}

\item{ctss}{A CTSS object with a score column.}

\item{useMulticore, nrCores}{See clusterCTSS.}

\item{ctss.clustered}{A \code{\link{data.table}} object representing the cluster ID
(\code{id}), chromosome coordinates (\code{chr}, \code{pos}, \code{strand}) and
the \code{score} of each CTSS.}

\item{removeSingletons}{Remove \dQuote{singleton} clusters that span only a single
nucleotide ? (default = FALSE).}

\item{keepSingletonsAbove}{Even if \code{removeSingletons = TRUE}, keep singletons when
their score is aboove threshold (default = \code{Inf}).}

\item{se}{A \code{\link{SummarizedExperiment}} object representing the CTSSes and
their expression in each sample.}
}
\value{
\code{.cluster.ctss.strand} returns an \link{data.table} object containing
arbitrary cluster IDs (as integers) for each CTSS.

\code{.cluster.ctss.chr} returns a \code{\link{data.table}} object representing the
chromosome coordinates (\code{chr}, \code{pos}, \code{strand}) of each CTSS, with their
cluster ID (\code{id}).

\code{.ctss2clusters} returns a \code{\link{data.table}} object representing the
cluster ID (\code{id}), chromosome coordinates (\code{chr}, \code{pos}, \code{strand}) and
the \code{score} of each CTSS.

\code{.summarize.clusters} returns GRanges describing the clusters.

\code{.distclu} returns GRanges describing the clusters.
}
\description{
The flow of data is that a \link{CTSS} object of CTSSes is
progressively deconstructed, and data to form the clusters is progressively
integrated in a \link{data.table} object, which is finally converted to \link{GRanges}
at the end.  Doing the whole clustering with \code{GRanges} is more elegant, but
looping on a \code{GRangesList} was just too slow.  Maybe the operation on the
\code{data.table} is more efficient because it is vectorised.

\code{.cluster.ctss.strand} does the strandless distance clustering
of strandless CTSS positions from a single chromosome.  Input does not need
to be sorted, but \emph{pay attention that the output is sorted}.

\code{.cluster.ctss.chr} does the stranded distance clustering of CTSS on a
single chromosome, by dispatching both strands to \code{.cluster.ctss.strand} and merging
the results, taking care keep the cluster IDs unique.  Be careful that this function does
not look at the score.

\code{.ctss2clusters} does the stranded distance clustering of CTSS.

\code{.summarize.clusters} calculates the number of CTSS, and
the position and score of a main peak, for each cluster.

\code{.distclu} receives the data from the main \code{clusterCTSS} and
dispatches each for (possibly parallel) processing.
}
\examples{
# Get example data
library(IRanges)
library(GenomicRanges)

#.cluster.ctss.strand
ctss.ipos.chr <- IPos(c(1,3,4,12,14,25,28))
CAGEr:::.cluster.ctss.strand(ctss.ipos.chr, 5)

ctss.chr <- CTSScoordinatesGR(exampleCAGEexp)
ctss.chr <- ctss.chr[strand(ctss.chr) == "+"]
ctss.ipos.chr <- ranges(ctss.chr)
# Same result if not sorted
identical(
  CAGEr:::.cluster.ctss.strand(ctss.ipos.chr, 20),
  CAGEr:::.cluster.ctss.strand(ctss.ipos.chr[sample(seq_along(ctss.ipos.chr))], 20)
)
# Returns an emtpy data.table object if given an empty IRanges object.
identical(CAGEr:::.cluster.ctss.strand(IPos(), 20), data.table::data.table())

#.cluster.ctss.chr
ctss.chr <- as(CTSScoordinatesGR(exampleCAGEexp), "CTSS.chr")
CAGEr:::.cluster.ctss.chr(ctss.chr, 20)

# .ctss2clusters
ctss <- CTSScoordinatesGR(exampleCAGEexp)
score(ctss) <- CTSSnormalizedTpmDF(exampleCAGEexp)[[1]]
seqnames(ctss)[rep(c(TRUE,FALSE), length(ctss) / 2)] <- "chr16"
ctss
clusters <- CAGEr:::.ctss2clusters(ctss, 20)
clusters

# .summarize.clusters
CAGEr:::.summarize.clusters(clusters)
CAGEr:::.summarize.clusters(clusters, removeSingletons = TRUE)
CAGEr:::.summarize.clusters(clusters, removeSingletons = TRUE, keepSingletonsAbove = 5)

# .distclu
CAGEr:::.distclu(CTSStagCountSE(exampleCAGEexp))
\dontrun{
CAGEr:::.distclu(CTSStagCountSE(exampleCAGEexp), useMulticore = TRUE)
}
}
